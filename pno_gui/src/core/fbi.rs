// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod yahp {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PRIORITY: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PRIORITY: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PRIORITY: [Priority; 5] = [
  Priority::Inactive,
  Priority::Once,
  Priority::Low,
  Priority::Medium,
  Priority::Highest,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Priority(pub i8);
#[allow(non_upper_case_globals)]
impl Priority {
  pub const Inactive: Self = Self(0);
  pub const Once: Self = Self(1);
  pub const Low: Self = Self(2);
  pub const Medium: Self = Self(3);
  pub const Highest: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Inactive,
    Self::Once,
    Self::Low,
    Self::Medium,
    Self::Highest,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Inactive => Some("Inactive"),
      Self::Once => Some("Once"),
      Self::Low => Some("Low"),
      Self::Medium => Some("Medium"),
      Self::Highest => Some("Highest"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Priority {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Priority {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Priority {
    type Output = Priority;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Priority {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Priority {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Priority {}
// struct TsySample, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct TsySample(pub [u8; 8]);
impl Default for TsySample { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for TsySample {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("TsySample")
      .field("sensor", &self.sensor())
      .field("value", &self.value())
      .field("ts_delta", &self.ts_delta())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TsySample {}
impl<'a> flatbuffers::Follow<'a> for TsySample {
  type Inner = &'a TsySample;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a TsySample>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a TsySample {
  type Inner = &'a TsySample;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<TsySample>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for TsySample {
    type Output = TsySample;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const TsySample as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for TsySample {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> TsySample {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    sensor: u16,
    value: u16,
    ts_delta: u32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_sensor(sensor);
    s.set_value(value);
    s.set_ts_delta(ts_delta);
    s
  }

  pub fn sensor(&self) -> u16 {
    let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_sensor(&mut self, x: u16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn value(&self) -> u16 {
    let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_value(&mut self, x: u16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn ts_delta(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_ts_delta(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Reprioritize, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Reprioritize(pub [u8; 4]);
impl Default for Reprioritize { 
  fn default() -> Self { 
    Self([0; 4])
  }
}
impl core::fmt::Debug for Reprioritize {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Reprioritize")
      .field("sensor", &self.sensor())
      .field("priority", &self.priority())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Reprioritize {}
impl<'a> flatbuffers::Follow<'a> for Reprioritize {
  type Inner = &'a Reprioritize;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Reprioritize>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Reprioritize {
  type Inner = &'a Reprioritize;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Reprioritize>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Reprioritize {
    type Output = Reprioritize;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Reprioritize as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(2)
    }
}

impl<'a> flatbuffers::Verifiable for Reprioritize {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Reprioritize {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    sensor: u16,
    priority: Priority,
  ) -> Self {
    let mut s = Self([0; 4]);
    s.set_sensor(sensor);
    s.set_priority(priority);
    s
  }

  pub fn sensor(&self) -> u16 {
    let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_sensor(&mut self, x: u16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn priority(&self) -> Priority {
    let mut mem = core::mem::MaybeUninit::<<Priority as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<Priority as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_priority(&mut self, x: Priority) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<Priority as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct PriorityConfig, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct PriorityConfig(pub [u8; 24]);
impl Default for PriorityConfig { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl core::fmt::Debug for PriorityConfig {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("PriorityConfig")
      .field("low_min", &self.low_min())
      .field("low_max", &self.low_max())
      .field("medium_min", &self.medium_min())
      .field("medium_max", &self.medium_max())
      .field("highest_min", &self.highest_min())
      .field("highest_max", &self.highest_max())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PriorityConfig {}
impl<'a> flatbuffers::Follow<'a> for PriorityConfig {
  type Inner = &'a PriorityConfig;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a PriorityConfig>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a PriorityConfig {
  type Inner = &'a PriorityConfig;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<PriorityConfig>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for PriorityConfig {
    type Output = PriorityConfig;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const PriorityConfig as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for PriorityConfig {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> PriorityConfig {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    low_min: u32,
    low_max: u32,
    medium_min: u32,
    medium_max: u32,
    highest_min: u32,
    highest_max: u32,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_low_min(low_min);
    s.set_low_max(low_max);
    s.set_medium_min(medium_min);
    s.set_medium_max(medium_max);
    s.set_highest_min(highest_min);
    s.set_highest_max(highest_max);
    s
  }

  pub fn low_min(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_low_min(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn low_max(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_low_max(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn medium_min(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_medium_min(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn medium_max(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_medium_max(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn highest_min(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_highest_min(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn highest_max(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[20..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_highest_max(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[20..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ToPiOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ToPi<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ToPi<'a> {
  type Inner = ToPi<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ToPi<'a> {
  pub const VT_TSY_TIMESTAMP: flatbuffers::VOffsetT = 4;
  pub const VT_TSY_PKTID: flatbuffers::VOffsetT = 6;
  pub const VT_SAMPLES: flatbuffers::VOffsetT = 8;
  pub const VT_ACKS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ToPi { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ToPiArgs<'args>
  ) -> flatbuffers::WIPOffset<ToPi<'bldr>> {
    let mut builder = ToPiBuilder::new(_fbb);
    builder.add_tsy_pktid(args.tsy_pktid);
    builder.add_tsy_timestamp(args.tsy_timestamp);
    if let Some(x) = args.acks { builder.add_acks(x); }
    if let Some(x) = args.samples { builder.add_samples(x); }
    builder.finish()
  }


  #[inline]
  pub fn tsy_timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ToPi::VT_TSY_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn tsy_pktid(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ToPi::VT_TSY_PKTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn samples(&self) -> flatbuffers::Vector<'a, TsySample> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, TsySample>>>(ToPi::VT_SAMPLES, None).unwrap()}
  }
  #[inline]
  pub fn acks(&self) -> flatbuffers::Vector<'a, u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(ToPi::VT_ACKS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ToPi<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("tsy_timestamp", Self::VT_TSY_TIMESTAMP, false)?
     .visit_field::<u64>("tsy_pktid", Self::VT_TSY_PKTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, TsySample>>>("samples", Self::VT_SAMPLES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("acks", Self::VT_ACKS, true)?
     .finish();
    Ok(())
  }
}
pub struct ToPiArgs<'a> {
    pub tsy_timestamp: u64,
    pub tsy_pktid: u64,
    pub samples: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, TsySample>>>,
    pub acks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for ToPiArgs<'a> {
  #[inline]
  fn default() -> Self {
    ToPiArgs {
      tsy_timestamp: 0,
      tsy_pktid: 0,
      samples: None, // required field
      acks: None, // required field
    }
  }
}

pub struct ToPiBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ToPiBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tsy_timestamp(&mut self, tsy_timestamp: u64) {
    self.fbb_.push_slot::<u64>(ToPi::VT_TSY_TIMESTAMP, tsy_timestamp, 0);
  }
  #[inline]
  pub fn add_tsy_pktid(&mut self, tsy_pktid: u64) {
    self.fbb_.push_slot::<u64>(ToPi::VT_TSY_PKTID, tsy_pktid, 0);
  }
  #[inline]
  pub fn add_samples(&mut self, samples: flatbuffers::WIPOffset<flatbuffers::Vector<'b , TsySample>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ToPi::VT_SAMPLES, samples);
  }
  #[inline]
  pub fn add_acks(&mut self, acks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ToPi::VT_ACKS, acks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ToPiBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ToPiBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ToPi<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ToPi::VT_SAMPLES,"samples");
    self.fbb_.required(o, ToPi::VT_ACKS,"acks");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ToPi<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ToPi");
      ds.field("tsy_timestamp", &self.tsy_timestamp());
      ds.field("tsy_pktid", &self.tsy_pktid());
      ds.field("samples", &self.samples());
      ds.field("acks", &self.acks());
      ds.finish()
  }
}
pub enum SensorConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SensorConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SensorConfig<'a> {
  type Inner = SensorConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SensorConfig<'a> {
  pub const VT_SENSOR_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PIN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SensorConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SensorConfigArgs
  ) -> flatbuffers::WIPOffset<SensorConfig<'bldr>> {
    let mut builder = SensorConfigBuilder::new(_fbb);
    builder.add_sensor_id(args.sensor_id);
    builder.add_pin(args.pin);
    builder.finish()
  }


  #[inline]
  pub fn sensor_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SensorConfig::VT_SENSOR_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pin(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SensorConfig::VT_PIN, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SensorConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("sensor_id", Self::VT_SENSOR_ID, false)?
     .visit_field::<u8>("pin", Self::VT_PIN, false)?
     .finish();
    Ok(())
  }
}
pub struct SensorConfigArgs {
    pub sensor_id: u16,
    pub pin: u8,
}
impl<'a> Default for SensorConfigArgs {
  #[inline]
  fn default() -> Self {
    SensorConfigArgs {
      sensor_id: 0,
      pin: 0,
    }
  }
}

pub struct SensorConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SensorConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sensor_id(&mut self, sensor_id: u16) {
    self.fbb_.push_slot::<u16>(SensorConfig::VT_SENSOR_ID, sensor_id, 0);
  }
  #[inline]
  pub fn add_pin(&mut self, pin: u8) {
    self.fbb_.push_slot::<u8>(SensorConfig::VT_PIN, pin, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SensorConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SensorConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SensorConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SensorConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SensorConfig");
      ds.field("sensor_id", &self.sensor_id());
      ds.field("pin", &self.pin());
      ds.finish()
  }
}
pub enum BoardConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoardConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoardConfig<'a> {
  type Inner = BoardConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoardConfig<'a> {
  pub const VT_BOARD_ID: flatbuffers::VOffsetT = 4;
  pub const VT_BOARD_SELECTOR: flatbuffers::VOffsetT = 6;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 8;
  pub const VT_SENSORS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoardConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoardConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<BoardConfig<'bldr>> {
    let mut builder = BoardConfigBuilder::new(_fbb);
    if let Some(x) = args.sensors { builder.add_sensors(x); }
    if let Some(x) = args.priority { builder.add_priority(x); }
    builder.add_board_id(args.board_id);
    builder.add_board_selector(args.board_selector);
    builder.finish()
  }


  #[inline]
  pub fn board_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BoardConfig::VT_BOARD_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn board_selector(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(BoardConfig::VT_BOARD_SELECTOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn priority(&self) -> &'a PriorityConfig {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PriorityConfig>(BoardConfig::VT_PRIORITY, None).unwrap()}
  }
  #[inline]
  pub fn sensors(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SensorConfig<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SensorConfig>>>>(BoardConfig::VT_SENSORS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoardConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("board_id", Self::VT_BOARD_ID, false)?
     .visit_field::<u8>("board_selector", Self::VT_BOARD_SELECTOR, false)?
     .visit_field::<PriorityConfig>("priority", Self::VT_PRIORITY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SensorConfig>>>>("sensors", Self::VT_SENSORS, true)?
     .finish();
    Ok(())
  }
}
pub struct BoardConfigArgs<'a> {
    pub board_id: u16,
    pub board_selector: u8,
    pub priority: Option<&'a PriorityConfig>,
    pub sensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SensorConfig<'a>>>>>,
}
impl<'a> Default for BoardConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoardConfigArgs {
      board_id: 0,
      board_selector: 0,
      priority: None, // required field
      sensors: None, // required field
    }
  }
}

pub struct BoardConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoardConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_board_id(&mut self, board_id: u16) {
    self.fbb_.push_slot::<u16>(BoardConfig::VT_BOARD_ID, board_id, 0);
  }
  #[inline]
  pub fn add_board_selector(&mut self, board_selector: u8) {
    self.fbb_.push_slot::<u8>(BoardConfig::VT_BOARD_SELECTOR, board_selector, 0);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: &PriorityConfig) {
    self.fbb_.push_slot_always::<&PriorityConfig>(BoardConfig::VT_PRIORITY, priority);
  }
  #[inline]
  pub fn add_sensors(&mut self, sensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SensorConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoardConfig::VT_SENSORS, sensors);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoardConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoardConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoardConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BoardConfig::VT_PRIORITY,"priority");
    self.fbb_.required(o, BoardConfig::VT_SENSORS,"sensors");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoardConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoardConfig");
      ds.field("board_id", &self.board_id());
      ds.field("board_selector", &self.board_selector());
      ds.field("priority", &self.priority());
      ds.field("sensors", &self.sensors());
      ds.finish()
  }
}
pub enum ConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Configuration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Configuration<'a> {
  type Inner = Configuration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Configuration<'a> {
  pub const VT_BOARDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Configuration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<Configuration<'bldr>> {
    let mut builder = ConfigurationBuilder::new(_fbb);
    if let Some(x) = args.boards { builder.add_boards(x); }
    builder.finish()
  }


  #[inline]
  pub fn boards(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoardConfig<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoardConfig>>>>(Configuration::VT_BOARDS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Configuration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoardConfig>>>>("boards", Self::VT_BOARDS, true)?
     .finish();
    Ok(())
  }
}
pub struct ConfigurationArgs<'a> {
    pub boards: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoardConfig<'a>>>>>,
}
impl<'a> Default for ConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConfigurationArgs {
      boards: None, // required field
    }
  }
}

pub struct ConfigurationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigurationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boards(&mut self, boards: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoardConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Configuration::VT_BOARDS, boards);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConfigurationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Configuration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Configuration::VT_BOARDS,"boards");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Configuration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Configuration");
      ds.field("boards", &self.boards());
      ds.finish()
  }
}
pub enum ToTsyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ToTsy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ToTsy<'a> {
  type Inner = ToTsy<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ToTsy<'a> {
  pub const VT_PI_TIMESTAMP: flatbuffers::VOffsetT = 4;
  pub const VT_PI_PKTID: flatbuffers::VOffsetT = 6;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 8;
  pub const VT_CONFIGURE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ToTsy { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ToTsyArgs<'args>
  ) -> flatbuffers::WIPOffset<ToTsy<'bldr>> {
    let mut builder = ToTsyBuilder::new(_fbb);
    builder.add_pi_pktid(args.pi_pktid);
    builder.add_pi_timestamp(args.pi_timestamp);
    if let Some(x) = args.configure { builder.add_configure(x); }
    if let Some(x) = args.priority { builder.add_priority(x); }
    builder.finish()
  }


  #[inline]
  pub fn pi_timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ToTsy::VT_PI_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pi_pktid(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ToTsy::VT_PI_PKTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn priority(&self) -> flatbuffers::Vector<'a, Reprioritize> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Reprioritize>>>(ToTsy::VT_PRIORITY, None).unwrap()}
  }
  #[inline]
  pub fn configure(&self) -> Option<Configuration<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Configuration>>(ToTsy::VT_CONFIGURE, None)}
  }
}

impl flatbuffers::Verifiable for ToTsy<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("pi_timestamp", Self::VT_PI_TIMESTAMP, false)?
     .visit_field::<u64>("pi_pktid", Self::VT_PI_PKTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Reprioritize>>>("priority", Self::VT_PRIORITY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Configuration>>("configure", Self::VT_CONFIGURE, false)?
     .finish();
    Ok(())
  }
}
pub struct ToTsyArgs<'a> {
    pub pi_timestamp: u64,
    pub pi_pktid: u64,
    pub priority: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Reprioritize>>>,
    pub configure: Option<flatbuffers::WIPOffset<Configuration<'a>>>,
}
impl<'a> Default for ToTsyArgs<'a> {
  #[inline]
  fn default() -> Self {
    ToTsyArgs {
      pi_timestamp: 0,
      pi_pktid: 0,
      priority: None, // required field
      configure: None,
    }
  }
}

pub struct ToTsyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ToTsyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pi_timestamp(&mut self, pi_timestamp: u64) {
    self.fbb_.push_slot::<u64>(ToTsy::VT_PI_TIMESTAMP, pi_timestamp, 0);
  }
  #[inline]
  pub fn add_pi_pktid(&mut self, pi_pktid: u64) {
    self.fbb_.push_slot::<u64>(ToTsy::VT_PI_PKTID, pi_pktid, 0);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Reprioritize>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ToTsy::VT_PRIORITY, priority);
  }
  #[inline]
  pub fn add_configure(&mut self, configure: flatbuffers::WIPOffset<Configuration<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Configuration>>(ToTsy::VT_CONFIGURE, configure);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ToTsyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ToTsyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ToTsy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ToTsy::VT_PRIORITY,"priority");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ToTsy<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ToTsy");
      ds.field("pi_timestamp", &self.pi_timestamp());
      ds.field("pi_pktid", &self.pi_pktid());
      ds.field("priority", &self.priority());
      ds.field("configure", &self.configure());
      ds.finish()
  }
}
}  // pub mod YAHP

